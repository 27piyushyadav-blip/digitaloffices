"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RefreshTokenResponseSchema = exports.RefreshTokenRequestSchema = exports.VerifyEmailResponseSchema = exports.VerifyEmailRequestSchema = exports.RequestEmailVerificationResponseSchema = exports.RequestEmailVerificationSchema = exports.GoogleOAuthResponseSchema = exports.GoogleOAuthRequestSchema = exports.LoginCredentialsResponseSchema = exports.LoginCredentialsRequestSchema = exports.RegisterResponseSchema = exports.RegisterRequestSchema = exports.AuthErrorSchema = exports.AuthErrorCodeSchema = exports.AuthSessionSchema = exports.AuthTokensSchema = exports.AuthUserSchema = exports.AuthProviderSchema = void 0;
const zod_1 = require("zod");
/**
 * Shared primitives
 */
exports.AuthProviderSchema = zod_1.z.enum(['credentials', 'google']);
exports.AuthUserSchema = zod_1.z.object({
    id: zod_1.z.string(), // agnostic: UUID / nanoid / DB-generated, but always exposed as string
    /** Public, human-readable, stable, unique. Used in frontend URLs (e.g. /profile/{username}). Generated by backend on registration. */
    username: zod_1.z.string().min(1).max(100),
    email: zod_1.z.string().email(),
    firstName: zod_1.z.string().min(1).max(100).trim(),
    lastName: zod_1.z.string().min(1).max(100).trim(),
    emailVerified: zod_1.z.boolean(),
    createdAt: zod_1.z.string().datetime(),
    updatedAt: zod_1.z.string().datetime(),
});
exports.AuthTokensSchema = zod_1.z.object({
    accessToken: zod_1.z.string(),
    refreshToken: zod_1.z.string(),
    accessTokenExpiresIn: zod_1.z.number().int().positive(), // seconds
    refreshTokenExpiresIn: zod_1.z.number().int().positive().optional(), // optional if refresh token is long-lived
    tokenType: zod_1.z.literal('Bearer').default('Bearer'),
});
exports.AuthSessionSchema = zod_1.z.object({
    user: exports.AuthUserSchema,
    tokens: exports.AuthTokensSchema,
});
/**
 * AuthSession is returned by endpoints that create or rotate an authenticated session:
 * - Login (credentials)
 * - Google OAuth callback
 * - Token refresh
 * - Email verification (auto-login)
 *
 * Register does NOT return AuthSession (only creates user and triggers email verification).
 */
/**
 * Error contracts
 */
exports.AuthErrorCodeSchema = zod_1.z.enum([
    'INVALID_CREDENTIALS',
    /** Used when registration fails due to email uniqueness (DB unique constraint). Do not pre-check email; backend maps constraint violation to this. */
    'EMAIL_ALREADY_IN_USE',
    'EMAIL_NOT_VERIFIED',
    'INVALID_OR_EXPIRED_TOKEN',
    'OAUTH_ERROR',
    'UNAUTHENTICATED',
    'UNAUTHORIZED',
    'UNKNOWN',
]);
exports.AuthErrorSchema = zod_1.z.object({
    code: exports.AuthErrorCodeSchema,
    message: zod_1.z.string(),
    /**
     * Optional machine-readable details for frontend logic / debugging.
     * Keep values JSON-serializable. Do not leak raw database error messages.
     */
    details: zod_1.z.record(zod_1.z.string(), zod_1.z.unknown()).optional(),
});
/**
 * Register
 *
 * Username is NOT sent by the frontend. The backend generates a unique username
 * and returns it in the registration response.
 */
exports.RegisterRequestSchema = zod_1.z.object({
    email: zod_1.z.string().email(),
    password: zod_1.z.string().min(8).max(128),
    firstName: zod_1.z.string().min(1).max(100).trim(),
    lastName: zod_1.z.string().min(1).max(100).trim(),
});
// Registration creates the user and triggers email verification.
// Response includes the backend-generated username. No tokens until email is verified.
exports.RegisterResponseSchema = zod_1.z.object({
    success: zod_1.z.literal(true),
    /** Backend-generated unique username (stable, human-readable, for URLs e.g. /profile/{username}). */
    username: zod_1.z.string().min(1).max(100),
    message: zod_1.z.string().optional(), // e.g., "Verification email sent"
});
/**
 * Login with credentials
 */
exports.LoginCredentialsRequestSchema = zod_1.z.object({
    email: zod_1.z.string().email(),
    password: zod_1.z.string(),
    rememberMe: zod_1.z.boolean().optional(),
});
exports.LoginCredentialsResponseSchema = exports.AuthSessionSchema;
/**
 * Google OAuth
 *
 * Assumption: frontend obtains a Google ID token and posts it to the backend.
 */
exports.GoogleOAuthRequestSchema = zod_1.z.object({
    idToken: zod_1.z.string(),
});
exports.GoogleOAuthResponseSchema = exports.AuthSessionSchema;
/**
 * Email verification
 */
// Trigger sending verification email for the authenticated user.
// Request body is intentionally empty for now; auth comes from the session.
exports.RequestEmailVerificationSchema = zod_1.z.object({});
exports.RequestEmailVerificationResponseSchema = zod_1.z.object({
    success: zod_1.z.literal(true),
});
// Verify email with token from the verification link.
exports.VerifyEmailRequestSchema = zod_1.z.object({
    token: zod_1.z.string(),
});
// Email verification proves email ownership and establishes an authenticated session.
// This is the entry point into the app after registration.
exports.VerifyEmailResponseSchema = exports.AuthSessionSchema;
/**
 * Token / session helpers
 */
exports.RefreshTokenRequestSchema = zod_1.z.object({
    refreshToken: zod_1.z.string(),
});
exports.RefreshTokenResponseSchema = exports.AuthSessionSchema;
//# sourceMappingURL=auth.contracts.js.map