import { z } from 'zod';

/**
 * Shared primitives
 */

export const AuthProviderSchema = z.enum(['credentials', 'google']);
export type AuthProvider = z.infer<typeof AuthProviderSchema>;

export const AuthUserSchema = z.object({
  id: z.string(), // agnostic: UUID / nanoid / DB-generated, but always exposed as string
  /** Public, human-readable, stable, unique. Used in frontend URLs (e.g. /profile/{username}). Generated by backend on registration. */
  username: z.string().min(1).max(100),
  email: z.string().email(),
  firstName: z.string().min(1).max(100).trim(),
  lastName: z.string().min(1).max(100).trim(),
  emailVerified: z.boolean(),
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
});
export type AuthUser = z.infer<typeof AuthUserSchema>;

export const AuthTokensSchema = z.object({
  accessToken: z.string(),
  refreshToken: z.string(),
  accessTokenExpiresIn: z.number().int().positive(), // seconds
  refreshTokenExpiresIn: z.number().int().positive().optional(), // optional if refresh token is long-lived
  tokenType: z.literal('Bearer').default('Bearer'),
});
export type AuthTokens = z.infer<typeof AuthTokensSchema>;

export const AuthSessionSchema = z.object({
  user: AuthUserSchema,
  tokens: AuthTokensSchema,
});
export type AuthSession = z.infer<typeof AuthSessionSchema>;

/**
 * AuthSession is returned by endpoints that create or rotate an authenticated session:
 * - Login (credentials)
 * - Google OAuth callback
 * - Token refresh
 * - Email verification (auto-login)
 *
 * Register does NOT return AuthSession (only creates user and triggers email verification).
 */

/**
 * Error contracts
 */

export const AuthErrorCodeSchema = z.enum([
  'INVALID_CREDENTIALS',
  /** Used when registration fails due to email uniqueness (DB unique constraint). Do not pre-check email; backend maps constraint violation to this. */
  'EMAIL_ALREADY_IN_USE',
  'EMAIL_NOT_VERIFIED',
  'INVALID_OR_EXPIRED_TOKEN',
  'OAUTH_ERROR',
  'UNAUTHENTICATED',
  'UNAUTHORIZED',
  'UNKNOWN',
]);
export type AuthErrorCode = z.infer<typeof AuthErrorCodeSchema>;

export const AuthErrorSchema = z.object({
  code: AuthErrorCodeSchema,
  message: z.string(),
  /**
   * Optional machine-readable details for frontend logic / debugging.
   * Keep values JSON-serializable. Do not leak raw database error messages.
   */
  details: z.record(z.string(), z.unknown()).optional(),
});
export type AuthError = z.infer<typeof AuthErrorSchema>;

/**
 * Register
 *
 * Username is NOT sent by the frontend. The backend generates a unique username
 * and returns it in the registration response.
 */

export const RegisterRequestSchema = z.object({
  email: z.string().email(),
  password: z.string().min(8).max(128),
  firstName: z.string().min(1).max(100).trim(),
  lastName: z.string().min(1).max(100).trim(),
});
export type RegisterRequest = z.infer<typeof RegisterRequestSchema>;

// Registration creates the user and triggers email verification.
// Response includes the backend-generated username. No tokens until email is verified.
export const RegisterResponseSchema = z.object({
  success: z.literal(true),
  /** Backend-generated unique username (stable, human-readable, for URLs e.g. /profile/{username}). */
  username: z.string().min(1).max(100),
  message: z.string().optional(), // e.g., "Verification email sent"
});
export type RegisterResponse = z.infer<typeof RegisterResponseSchema>;

/**
 * Login with credentials
 */

export const LoginCredentialsRequestSchema = z.object({
  email: z.string().email(),
  password: z.string(),
  rememberMe: z.boolean().optional(),
});
export type LoginCredentialsRequest = z.infer<typeof LoginCredentialsRequestSchema>;

export const LoginCredentialsResponseSchema = AuthSessionSchema;
export type LoginCredentialsResponse = z.infer<typeof LoginCredentialsResponseSchema>;

/**
 * Google OAuth
 *
 * Assumption: frontend obtains a Google ID token and posts it to the backend.
 */

export const GoogleOAuthRequestSchema = z.object({
  idToken: z.string(),
});
export type GoogleOAuthRequest = z.infer<typeof GoogleOAuthRequestSchema>;

export const GoogleOAuthResponseSchema = AuthSessionSchema;
export type GoogleOAuthResponse = z.infer<typeof GoogleOAuthResponseSchema>;

/**
 * Email verification
 */

// Trigger sending verification email for the authenticated user.
// Request body is intentionally empty for now; auth comes from the session.
export const RequestEmailVerificationSchema = z.object({});
export type RequestEmailVerification = z.infer<typeof RequestEmailVerificationSchema>;

export const RequestEmailVerificationResponseSchema = z.object({
  success: z.literal(true),
});
export type RequestEmailVerificationResponse = z.infer<
  typeof RequestEmailVerificationResponseSchema
>;

// Verify email with token from the verification link.
export const VerifyEmailRequestSchema = z.object({
  token: z.string(),
});
export type VerifyEmailRequest = z.infer<typeof VerifyEmailRequestSchema>;

// Email verification proves email ownership and establishes an authenticated session.
// This is the entry point into the app after registration.
export const VerifyEmailResponseSchema = AuthSessionSchema;
export type VerifyEmailResponse = z.infer<typeof VerifyEmailResponseSchema>;

/**
 * Token / session helpers
 */

export const RefreshTokenRequestSchema = z.object({
  refreshToken: z.string(),
});
export type RefreshTokenRequest = z.infer<typeof RefreshTokenRequestSchema>;

export const RefreshTokenResponseSchema = AuthSessionSchema;
export type RefreshTokenResponse = z.infer<typeof RefreshTokenResponseSchema>;

